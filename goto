#!/usr/bin/perl
use strict;
use warnings;
use v5.10;
use Term::ReadKey;
use Socket;
use Cwd qw(getcwd);
use File::Basename;
use File::Path qw(make_path);
use Getopt::Long;

##############################################################
## goto - 单文件同步终极版 + 支持可选代理（专为 luqiucheng）
## 配置目录：~/Documents/config/goto/goto.ini（iCloud 同步）
##############################################################

my $BASE_DIR = "$ENV{HOME}/Documents/config/goto";
my $INI_FILE = "$BASE_DIR/goto.ini";

unless (-d $BASE_DIR) {
    make_path($BASE_DIR) or die "无法创建目录 $BASE_DIR: $!\n";
    say "创建配置目录：$BASE_DIR";
}

my $config = { global => { user => 'root', port => 22 } };
load_config();
# 迁移现有密码到 Keychain
migrate_passwords_to_keychain();

my $mode      = 'ssh';
my $recursive = 0;
my $quiet     = 0;
my $proxy     = 0;
my $proxy_host = '127.0.0.1';
my $proxy_port = 7890;  # Clash/V2Ray 等默认 SOCKS5 端口，可自行修改

GetOptions(
    "up"          => sub { $mode = 'up' },
    "down"        => sub { $mode = 'down' },
    "ping"        => sub { $mode = 'ping' },
    "test"        => sub { $mode = 'test' },
    "list"        => sub { $mode = 'list' },
    "edit"        => sub { $mode = 'edit' },
    "delete"      => sub { $mode = 'delete' },
    "r|recursive" => \$recursive,
    "q|quiet"     => \$quiet,
    "x|proxy"     => \$proxy,
    "h|help"      => sub { print_help(); exit 0 },
) or exit 1;

my $target = shift @ARGV // '';
if (!$target && $mode !~ /^(list|edit|delete)$/) {
    print_help();
}

my $default_user = $config->{global}{user} // 'root';
my $default_port = $config->{global}{port} // 22;

# 从配置文件读取代理设置（如果存在）
if (exists $config->{global}{proxy_host}) {
    $proxy_host = $config->{global}{proxy_host};
}
if (exists $config->{global}{proxy_port}) {
    $proxy_port = $config->{global}{proxy_port};
}

if ($mode eq 'list') { list_hosts(); exit 0; }
if ($mode eq 'edit') { exec($ENV{EDITOR} // 'nano', $INI_FILE); exit 0; }
if ($mode eq 'delete') {
    my $alias = shift @ARGV;
    die "请指定要删除的别名\n" unless $alias;
    delete_alias($alias);
    exit 0;
}

my ($ip, $port, $user, $pass, $alias) = resolve_target($target, $default_user, $default_port);


if    ($mode eq 'ssh')  { ssh_connect($ip, $port, $user, $pass, $alias); }
elsif ($mode eq 'ping') { exec("ping", "-c", "4", $ip); }
elsif ($mode eq 'test') { test_connection($ip, $port, $user, $pass); }
elsif ($mode eq 'up')   { scp_transfer('up',   $ip, $port, $user, $pass, @ARGV); }
elsif ($mode eq 'down') { scp_transfer('down', $ip, $port, $user, $pass, @ARGV); }
else { die "未知模式: $mode\n"; }

# ==================== 子函数 ====================

# macOS Keychain 密码管理函数
sub keychain_get_password {
    my $alias = shift;
    my $service = "goto";
    my $account = $alias;
    
    my $password = `security find-generic-password -a "$account" -s "$service" -w 2>/dev/null`;
    chomp $password;
    return $password if $? == 0 && $password ne '';
    return undef;
}

sub keychain_set_password {
    my ($alias, $password) = @_;
    my $service = "goto";
    my $account = $alias;
    
    # 先删除旧密码（如果存在）
    system("security delete-generic-password -a \"$account\" -s \"$service\" >/dev/null 2>&1");
    
    # 添加到登录 keychain（会同步到 iCloud Keychain，如果已启用）
    # 使用 -T 参数指定可访问的程序，确保可以同步
    # 使用 -U 参数更新（如果已存在）
    # 明确指定 login.keychain-db 以确保同步到 iCloud
    my $keychain_path = "$ENV{HOME}/Library/Keychains/login.keychain-db";
    my $cmd = "security add-generic-password -a \"$account\" -s \"$service\" -w \"$password\" -T /usr/bin/security -T /usr/bin/ssh -T /usr/bin/scp -U";
    
    # 明确指定登录 keychain（确保同步到 iCloud）
    if (-e $keychain_path) {
        $cmd .= " \"$keychain_path\"";
    } else {
        # 如果 login.keychain-db 不存在，尝试 login.keychain（旧版本）
        my $old_keychain = "$ENV{HOME}/Library/Keychains/login.keychain";
        if (-e $old_keychain) {
            $cmd .= " \"$old_keychain\"";
        }
    }
    
    my $result = system("$cmd >/dev/null 2>&1");
    
    if ($result == 0) {
        # 验证是否成功添加
        my $test = `security find-generic-password -a "$account" -s "$service" -w 2>/dev/null`;
        chomp $test;
        if ($test eq $password) {
            return 1;
        }
    }
    return 0;
}

sub keychain_delete_password {
    my $alias = shift;
    my $service = "goto";
    my $account = $alias;
    
    system("security delete-generic-password -a \"$account\" -s \"$service\" >/dev/null 2>&1");
    return $? == 0;
}

# 迁移现有 Base64 密码到 Keychain
sub migrate_passwords_to_keychain {
    # 动态加载 MIME::Base64（仅在迁移时需要）
    eval { require MIME::Base64; MIME::Base64->import('decode_base64'); };
    return if $@;  # 如果无法加载模块，跳过迁移
    
    my $migrated = 0;
    
    for my $alias (keys %$config) {
        next if $alias eq 'global';
        next unless exists $config->{$alias}{password};
        
        # 检查 Keychain 中是否已有密码
        next if keychain_get_password($alias);
        
        # 从配置文件读取 Base64 密码并迁移
        my $base64_pass = $config->{$alias}{password};
        my $password = decode_base64($base64_pass);
        
        if (keychain_set_password($alias, $password)) {
            # 从配置文件中删除 password 字段
            delete $config->{$alias}{password};
            $migrated++;
        }
    }
    
    if ($migrated > 0) {
        my $default_user = $config->{global}{user} // 'root';
        my $default_port = $config->{global}{port} // 22;
        save_config($default_user, $default_port);
    }
}

sub resolve_target {
    my ($input, $default_user, $default_port) = @_;

    # 如果配置里已经有这个别名，直接使用配置
    if (exists $config->{$input}) {
        my $h = $config->{$input};
        my $ip = $h->{ip} // die "别名 $input 配置中缺少 ip\n";
        my $port = $h->{port} // $default_port;
        my $user = $h->{user} // $default_user;
        my $pass = keychain_get_password($input) // '';
        return ($ip, $port, $user, $pass, $input);
    }
    
    # 新别名：触发添加流程
    add_alias($input, $default_user, $default_port);
    # 递归调用，读取刚添加的配置
    return resolve_target($input, $default_user, $default_port);
}

sub add_alias {
    my ($alias, $default_user, $default_port) = @_;
    
    print "IP: "; chomp(my $ip = <STDIN>);
    die "无效 IP\n" unless is_ip($ip);

    print "端口 [$default_port]: "; chomp(my $p = <STDIN>); $p = $default_port if $p eq '';
    print "用户 [$default_user]: "; chomp(my $u = <STDIN>); $u = $default_user if $u eq '';

    print "密码（留空用密钥）: ";
    ReadMode('noecho');
    chomp(my $pass = <STDIN>);
    ReadMode('restore');
    print "\n";

    $config->{$alias} = {
        ip   => $ip,
        port => $p,
        user => $u,
    };
    
    # 将密码存储到 Keychain（如果提供了密码）
    if ($pass ne '') {
        keychain_set_password($alias, $pass);
    } else {
        keychain_delete_password($alias);
    }
    
    save_config($default_user, $default_port);
}

sub load_config {
    return unless -f $INI_FILE;
    open my $fh, '<', $INI_FILE or die "无法读取 $INI_FILE: $!\n";
    my $section = 'global';
    while (<$fh>) {
        chomp;
        next if /^\s*(#|$)/;
        if (/^\[(.+)\]$/) {
            $section = $1;
            $config->{$section} //= {};
        } elsif (/^\s*(\S+?)\s*=\s*(.*)$/) {
            $config->{$section}{$1} = $2;
        }
    }
    close $fh;
}

sub save_config {
    my ($default_user, $default_port) = @_;
    open my $fh, '>', $INI_FILE or die "无法写入 $INI_FILE: $!\n";
    print $fh "[global]\n";
    print $fh "user=$default_user\n";
    print $fh "port=$default_port\n";
    # 保存代理设置（如果已修改）
    if (exists $config->{global}{proxy_host}) {
        print $fh "proxy_host=$config->{global}{proxy_host}\n";
    }
    if (exists $config->{global}{proxy_port}) {
        print $fh "proxy_port=$config->{global}{proxy_port}\n";
    }
    print $fh "\n";

    for my $sec (sort grep { $_ ne 'global' } keys %$config) {
        print $fh "[$sec]\n";
        # 不再保存 password 字段，密码存储在 Keychain 中
        for my $k (qw(ip port user)) {
            print $fh "$k=$config->{$sec}{$k}\n" if exists $config->{$sec}{$k};
        }
        print $fh "\n";
    }
    close $fh;
    chmod 0600, $INI_FILE;
}

sub build_proxy_command {
    my ($proxy_host, $proxy_port) = @_;
    # 检查 nc 命令是否存在
    unless (`which nc 2>/dev/null`) {
        die "错误: 未找到 'nc' 命令，无法使用代理。请安装 netcat。\n";
    }
    return "ProxyCommand=nc -x $proxy_host:$proxy_port %h %p";
}

# 测试密码是否正确（不保存）
sub test_password {
    my ($ip, $port, $user, $pass, $use_proxy, $proxy_host, $proxy_port) = @_;
    
    my @cmd = ('ssh', '-o', 'StrictHostKeyChecking=no', 
               '-o', 'ConnectTimeout=5',
               '-o', 'PasswordAuthentication=yes',
               '-o', 'PreferredAuthentications=password,publickey',
               '-p', $port, 
               "$user\@$ip",
               'echo "test"');
    
    # 如果使用代理，添加代理命令（与 ssh_connect 保持一致）
    if ($use_proxy) {
        my $proxy_cmd = build_proxy_command($proxy_host, $proxy_port);
        push @cmd, '-o', $proxy_cmd;
    }
    
    unless (`which sshpass 2>/dev/null`) {
        return 0;  # 如果没有 sshpass，无法测试
    }
    
    unshift @cmd, 'sshpass', '-p', $pass;
    
    # 执行测试，捕获输出和错误
    open my $pipe, '-|', @cmd, '2>&1' or return 0;
    my $output = '';
    while (<$pipe>) {
        $output .= $_;
    }
    close $pipe;
    my $result = $?;
    
    # 检查是否是连接错误（可能是代理问题）还是认证错误
    if ($result != 0) {
        chomp $output;
        # 如果是连接错误（Connection refused, Connection timed out 等），不是密码错误
        if ($output =~ /Connection (refused|timed out|reset)/) {
            # 返回 -1 表示连接失败（不是密码错误）
            return -1;
        }
        # 如果是认证错误（Permission denied），返回 0 表示密码错误
        if ($output =~ /Permission denied/) {
            return 0;
        }
    }
    
    return $result == 0 ? 1 : 0;
}

sub ssh_connect {
    my ($ip, $port, $user, $pass, $alias) = @_;
    
    # 如果没有密码，提示用户输入并验证后保存到 Keychain
    if (!$pass && $alias) {
        my $max_attempts = 3;
        my $attempt = 0;
        
        while ($attempt < $max_attempts) {
            print "请输入密码: ";
            ReadMode('noecho');
            chomp($pass = <STDIN>);
            ReadMode('restore');
            print "\n";
            
            next if $pass eq '';
            
            # 测试密码是否正确
            my $test_result = test_password($ip, $port, $user, $pass, $proxy, $proxy_host, $proxy_port);
            
            if ($test_result == 1) {
                keychain_set_password($alias, $pass);
                last;
            } elsif ($test_result == -1) {
                $attempt++;
                die "连接失败\n" if $attempt >= $max_attempts;
                $pass = '';
            } else {
                $attempt++;
                die "密码错误\n" if $attempt >= $max_attempts;
                $pass = '';
            }
        }
    }
    
    my @cmd = ('ssh', 
               '-o', 'StrictHostKeyChecking=no', 
               '-o', 'ServerAliveInterval=60',      # 每 60 秒发送一次 keepalive
               '-o', 'ServerAliveCountMax=3',      # 最多 3 次无响应后断开（共 180 秒）
               '-p', $port, 
               "$user\@$ip");

    if ($proxy) {
        push @cmd, '-o', build_proxy_command($proxy_host, $proxy_port);
    }

    if ($pass) {
        unless (`which sshpass 2>/dev/null`) {
            die "错误: 未找到 'sshpass' 命令。请安装 sshpass 或使用 SSH 密钥。\n";
        }
        unshift @cmd, 'sshpass', '-p', $pass;
    }

    exec(@cmd);
}

sub scp_transfer {
    my ($dir, $ip, $port, $user, $pass, $p1, $p2) = @_;
    die "需要两个路径参数\n" unless $p1 && $p2;

    my @opts = ('scp', '-P', $port, '-o', 'StrictHostKeyChecking=no');
    push @opts, '-r' if $recursive;

    if ($proxy) {
        push @opts, '-o', build_proxy_command($proxy_host, $proxy_port);
    }

    my ($src, $dst);
    if ($dir eq 'up') {
        die "本地路径不存在: $p1\n" unless -e $p1;
        $src = $p1;
        $dst = "$user\@$ip:$p2";
    } else {
        $src = "$user\@$ip:$p1";
        $dst = $p2;
        $dst =~ s{^~}{$ENV{HOME}};
        $dst = getcwd() if $dst eq '.' || $dst eq './';
        my $dst_dir = dirname($dst);
        make_path($dst_dir) if $dst_dir && $dst_dir ne '.';
    }

    if ($pass) {
        unless (`which sshpass 2>/dev/null`) {
            die "错误: 未找到 'sshpass' 命令。请安装 sshpass 或使用 SSH 密钥。\n";
        }
        unshift @opts, 'sshpass', '-p', $pass;
    }

    my $exit_code = system(@opts, $src, $dst);
    if ($exit_code != 0) {
        my $exit_value = $exit_code >> 8;
        die "传输失败，退出码: $exit_value\n";
    }
}

sub list_hosts {
    my $count = grep { $_ ne 'global' } keys %$config;
    if ($count == 0) {
        return;
    }
    printf "  %-12s  %-15s  %-6s  %s\n", "别名", "IP", "端口", "用户";
    for my $name (sort grep { $_ ne 'global' } keys %$config) {
        my $h = $config->{$name};
        printf "  %-12s  %-15s  %-6s  %s\n",
            $name,
            $h->{ip} // '-',
            $h->{port} // '22',
            $h->{user} // '-';
    }
}

sub delete_alias {
    my $alias = shift;
    unless (exists $config->{$alias}) {
        die "错误: 别名 [$alias] 不存在\n";
    }
    print "确认删除别名 [$alias]？(y/N): ";
    chomp(my $confirm = <STDIN>);
    unless (lc($confirm) eq 'y') {
        return;
    }
    delete $config->{$alias};
    keychain_delete_password($alias);
    my $default_user = $config->{global}{user} // 'root';
    my $default_port = $config->{global}{port} // 22;
    save_config($default_user, $default_port);
}

sub test_connection {
    my ($ip, $port, $user, $pass) = @_;
    
    my @cmd = ('ssh', '-o', 'StrictHostKeyChecking=no', 
               '-o', 'ConnectTimeout=5',
               '-p', $port, 
               "$user\@$ip",
               'echo "连接成功！"');
    
    if ($proxy) {
        push @cmd, '-o', build_proxy_command($proxy_host, $proxy_port);
    }
    
    if ($pass) {
        unless (`which sshpass 2>/dev/null`) {
            die "错误: 未找到 'sshpass' 命令。请安装 sshpass 或使用 SSH 密钥。\n";
        }
        # 使用密码时，启用密码认证
        push @cmd, '-o', 'PasswordAuthentication=yes';
        push @cmd, '-o', 'PreferredAuthentications=password,publickey';
        unshift @cmd, 'sshpass', '-p', $pass;
    } else {
        # 没有密码时，使用 BatchMode 快速失败（仅使用密钥）
        push @cmd, '-o', 'BatchMode=yes';
    }
    
    # 执行测试并捕获输出
    open my $pipe, '-|', @cmd, '2>&1' or die "无法执行测试命令\n";
    my $output = '';
    while (<$pipe>) {
        $output .= $_;
        print $_ unless $quiet;  # 显示实时输出
    }
    close $pipe;
    my $exit_code = $?;
    
    if ($exit_code == 0) {
        exit 0;
    } else {
        my $exit_value = $exit_code >> 8;
        chomp $output;
        if ($output =~ /Permission denied/) {
            if ($pass) {
                die "✗ 连接测试失败：认证失败（密码可能不正确或需要使用 SSH 密钥）\n";
            } else {
                die "✗ 连接测试失败：认证失败（需要密码或 SSH 密钥，请检查 Keychain 中是否有密码）\n";
            }
        } elsif ($output =~ /Connection refused|Connection timed out|Network is unreachable/) {
            die "✗ 连接测试失败：无法连接到服务器（$output）\n";
        } else {
            die "✗ 连接测试失败，退出码: $exit_value" . ($output ? " ($output)" : "") . "\n";
        }
    }
}

sub is_ip {
    my $i = shift;
    return 0 unless $i =~ /^(\d{1,3}\.){3}\d{1,3}$/;
    return eval { inet_aton($i); 1 };
}

sub print_help {
    print <<'EOF';
goto - SSH 连接和文件传输工具

用法：
  goto <别名|IP>                  SSH 登录
  goto -x <别名|IP>               通过代理登录
  goto up   [-x] [-r] <别名|IP> <本地> <远程>    上传文件
  goto down [-x] [-r] <别名|IP> <远程> <本地>    下载文件
  goto ping <别名|IP>             Ping 测试
  goto --test <别名|IP>           测试连接
  goto --list                     列出别名
  goto --edit                     编辑配置
  goto --delete <别名>            删除别名

参数：
  -x, --proxy      启用 SOCKS5 代理
  -r, --recursive  递归传输目录
  -q, --quiet      安静模式

配置：~/Documents/config/goto/goto.ini
密码存储在 macOS Keychain，支持 iCloud 同步
EOF
    exit 0;
}